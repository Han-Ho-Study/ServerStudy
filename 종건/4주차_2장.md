## 2.1 네트워크 컴퓨터를 구성하는 기기

단말기 (terminal) : PC, 노트북, 스마트폰, 서버 컴퓨터 등

구분<br>
클라이언트 : 사람이 만지는 기기<br>
서버 : 단말기에 서비스를 제공하는 무인 컴퓨터<br>

![4주차_링 위상.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/415a5c847174319b9a7d0b5e64315963a9e821b3/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%EB%A7%81%20%EC%9C%84%EC%83%81.PNG)

### 로컬 지역 네트워크(Local Area Network) 혹은 LAN, 별 위상(star topology)
LAN은 사용자가 직접 구축해서 운영하기 어렵지 않음 <br>
심지어 제조사가 서로 달라도 기기 간의 통신 규약이 서로 달라도 가능하다. OSI 모델의 표준만 지키면 된다! <br>

![4주차_별 위상.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%EB%B3%84%20%EC%9C%84%EC%83%81.PNG)

### OSI(Open Systems Interconnection reference) 모델
컴퓨터 네트워크 통신에 대한 국제 표준, 왜 대학 수업에 지겹게 나왔는지 이제 이해함
 

#### 2.1.1 OSI 모델
계층 1: 물리 계층
물리 계층에서는 하드웨어를 다룹니다. 예를 들어 보낼 데이터를 어떤 파형의 전류로 보낼지 등을 정의합니다.

계층 2: 데이터 링크 계층
로컬 지역 네트워크(LAN)에서 통신을 가능하게 합니다.

계층 3: 네트워크 계층
뒤에서 설명하겠지만, 광역 통신망(WAN)에서 통신을 가능하게 합니다.

계층 4: 전송 계층
이 계층에서는 상대방에게 데이터가 반드시 도착하게 합니다. 계층 2에서는 상대방에게 데이터가 변조 없이 가게는 하지만, 반드시 가게 하는 것은 아닙니다. 이 계층에서는 상대방에게 데이터가 반드시 가게 해 줍니다.

계층 5: 세션 계층, 계층 6: 표현 계층, 계층 7: 응용 계층
응용 프로그램이나 운영체제 안 모듈이 다른 컴퓨터의 응용 프로그램이나 운영체제 모듈과 통신을 하는 동안 논리적 연결 단위나 기능들은 계층 5 - 7에서 다룹니다. 
그 예로 동영상 스트리밍의 통신 규약(MPEG), 통신 암호화 규약(SSL), 웹 브라우저와 웹 서버 간 통신 규약(HTTP) 등을 들 수 있습니다.
여러분이 게임 프로그램을 만드는 것도 결국 이 계층 5 - 7 중 어딘가를 정의하는 셈입니다.


#### 2.1.2 OSI 모델의 계층 2
OSI 모델의 계층 2를 구성하는 단말기들은 작은 마을과 같다.

* 각 단말기는 고유한 주소를 갖는다.
* 단말기는 데이터를 프레임(frame)이라는 단위로 주고받는다.

##### 페이로드(payload) : 전송하고자 하는 실제 데이터		- 편지지
##### 헤더(header) : 전송에 필요한 정보 (수신자, 송신자 등)	- 편지봉투
##### 프레임(frame) : 페이로드 + 헤더를 합친 결과물		- 봉투에 편지지가 들어있음

![4주차_프레임.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%ED%94%84%EB%A0%88%EC%9E%84.PNG)


LAN의 크기가 제각각 -> 일반적으로 빌딩 한 층 정도를 다룰 수 있다.
이 이상은 다음과 같은 문제가 있다.
* 스위치 하나가 연결할 수 있는 단말기 수가 제한되어 있음
* 단말기들 각각의 주소를 모두 고유하게 만들기 어려움

이 문제의 해결책 중 하나는 서로 다른 네트워크 기기 간에 연결하는 것. 다시 말해서 LAN과 LAN을 연결하는 것.


### 광역 통신망(Wide Area Network) 혹은 WAN
서로 다른 LAN이 맞물려 연결된 것

![4주차_WAN.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_WAN.PNG)

서로 다른 LAN이 모두 연결된 WAN에서는 또 다른 규약이 필요하다. 이를 설명하는 것이 OSI 모델의 계층 3


#### 2.1.3 OSI 모델의 계층 3
마을 -> 도시가 되면 집마다 번호를 매기는 방식에 한계가 생김..
ActionType, ActionSubType, ActionSpecialType..

WAN에서도 직접 데이터를 건네는 것이 아니라, 계층적으로 데이터를 건네주는 방식으로 작동

### 라우터(router)
어떤 데이터가 단말기에서 스위치로 갔는데 그 데이터를 스위치가 직접 건네줄 수 없는 곳에 있으면 <br>
이를 취급할 수 있는 곳으로 데이터를 보내야 한다. 이러한 일을 담당하는 네트워크 기기

OSI 모델의 계층 3에서 흔히 접하는 것은 "인터넷 프로토콜(Internet Protocol) 혹은 IP"<br>
인터넷 프로토콜에서는 주소 형식이 8비트 숫자 4개1로 구성되어 있음. IP 주소라고 칭하는 것이 바로 이것<br>

단말기 A에서 데이터 X를 다른 단말기 B로 보내려고 하면, 데이터 X는 OSI 모델 계층 3의 인터넷 프로토콜에 의해 "IP 패킷(packet)" 형태로 포장된다.<br>

가정에서 사용하는 인터넷 공유기도 일종의 라우터<br>

## 2.2 인터넷
OSI 모델 계층 3의 인터넷 프로토콜, 즉 IP 규약을 지키면 기기 종류와 상관없이 서로 통신할 수 있다. <br>
통신 회선의 형태가 랜선이든 광섬유, 무선, 전화선 등 어떤 것이든 상관 X<br>
서로 다른 종류의 많은 스위치와 라우터가 연결되어 지구를 뒤덮고 있고 이것을 인터넷이라고 하기로 했다.<br>


## 2.3 컴퓨터 네트워크 데이터
데이터 단위<br>
계층 2 : 프레임<br>
계층 3 : 패킷 <br>

그렇지만 네트워크나 서버 앱을 개발할 때는 이를 직접 다룰 일이 흔하지는 않다. 그 대신 스트림과 메시지라는 것을 주로 다룬다.

#### 2.3.1 스트림 형식
스트림(stream)이란 데이터의 흐름<br>
스트림 자체는 데이터를 중간에 구별하지 않는다.<br>

![4주차_스트림.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%EC%8A%A4%ED%8A%B8%EB%A6%BC.PNG)

TCP 프로토콜이 이러한 성질을 가지기 때문에 모든 인터넷 프로그램은 이러한 특징을 고려할 수 밖에 없다.

스트림 형식으로 데이터를 송수신할 때, 데이터가 여러 부분으로 나뉘어 있다면 여러분이 이것을 따로 정의해 주어야 한다<br>
어떤 데이터를 보내기 전에, 보낼 데이터 크기를 먼저 보낸다든지 데이터 시작이나 끝을 알리는 특정 기호를 추가한다든지<br>
전자는 헤더를 붙이는 방식, 후자는 구분자(delimiter)를 이용하는 방식<br>

![4주차_해더_구분자.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%ED%95%B4%EB%8D%94_%EA%B5%AC%EB%B6%84%EC%9E%90.PNG)

검사의 가변 패킷은 헤더겠네요

#### 2.3.2 메시지 형식
스트림과 달리 데이터 시작과 끝을 구별할 수 있음<br>
aaa, bbb, ccc 3개를 송신했을 때 받는 쪽에서 aaa, bbb, ccc 3개를 받는다.<br>
각 데이터가 정확히 구별되는 것을 메시지 형식이라 함<br>

네트워크 게임에서는 메시지 형식의 데이터 송수신이 보편적. IP 패킷을 직접 다루는 일은 흔하지 않지만(?) IP 패킷의 특징은 알아 두면 좋다.<br>

IP 패킷에는 주고받는 데이터, 즉 페이로드의 크기와 송신자 주소, 수신자 주소, 체크섬(checksum) 등이 있다.<br>


IP 패킷 하나의 크기는 제한되어 있다. <br>
크기 제한은 라우터마다 다름, 보통 1300바이트 정도로, 600바이트 ~ 9000바이트<br>

IP 패킷의 크기는 제한적이지만, 스트림이나 메시지에서는 이러한 제한이 없다.<br>
운영체제에 내장된 네트워크 모듈인 네트워크 스택에서 프로그램이 보내고 받는 스트림과 메시지를 관리해 주기 때문<br>

단편화(fragmentation) : 프로그램이 매우 긴 스트림을 송신할 때 운영체제는 이를 IP 패킷의 크기 제한에 맞추어 여러 조각을 냄<br>
각 조각은 IP 패킷 하나하나가 되어 받는 쪽에 송신합니다.<br>

받는 쪽에서는 이 조각들을 받아 조립한 후 스트림 형태로 복원 (이 과정도 운영체제 안에서 진행)<br>
조립된 스트림은 프로그램으로 넘어가 처리 (스트림뿐만 아니라 메시지나 데이터그램도 동일)<br>


## 2.4 컴퓨터 네트워크 식별자
주소는 인터넷에서 모두 고유<br>
IPv4 -> 127.0.0.1 형식, 40억 개 이상 배정 X, 예약 범위도 존재<br>
IPv6으로의 전환이 필요<br>

포트(port) : IP 주소 안에서도 누가 주고받는 것인지 식별하는 역할 (어떤 프로세스인지)<br>
포트는 2바이트 정수<br>

끝점(endpoint):  <IP 주소:포트> 형식<br>

끝점 형식으로 들어가면 너무 번거롭다. 영어 문장 형식으로 입력하면 이를 IP 주소로 변환하는 것이 보편화되어 있다.<br>
호스트 이름(host name) : 입력하는 영어 단어 형식의 기기 주소<br>

도메인 이름 서버(DNS Server) : 우리가 호스트 이름을 입력하면 컴퓨터는 이를 IP 주소로 변환하는 역할<br>
호스트 이름을 입력하면 운영체제는 이를 DNS 서버에 물어본다.<br>

![4주차_호스트이름.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%ED%98%B8%EC%8A%A4%ED%8A%B8%EC%9D%B4%EB%A6%84.PNG)


## 2.5 컴퓨터 네트워크의 품질과 특성
#### 2.5.1 네트워크의 품질을 저해하는 것들
스위치, 라우터 : 데이터를 받으면 데이터 안의 내용 중 헤더를 먼저 읽음 <br>
-> 데이터를 어디로 전달해야 할지 판단하고자 기기 자체에 내장된 메모리를 액세스 <br>
-> CPU 연산도 해야함 (처리량이 많으면 과부하) <br>

##### 처리할 수 있는 한계를 넘는 데이터 크게 2가지 처리
1. 자기가 처리할 수 있는 것 이상을 버림<br>
   (패킷 드롭(drop), 결과적으로 패킷 유실(packet loss)) -> 공급자 입장에선 소수만 피해받게..
2. 아직 처리하지 못한 것들을 메모리에 누적시킴<br>
   (장시간 지속되면 라우터 뻗음, 재부팅해버림)

패킷 유실 현상은 데이터가 오가는 선로때문에도 발생할 수 있음<br>

계층 1에선 송신자가 디지털 정보를 아날로그 정보로 변환해서 보낸 아날로그 정보를 진폭, 주파수 등을 파악해 데이터 정보로 바꾼다. <br>
이걸 계층 2, 3으로 넘기는데 여기서 아날로그 신호에 변화가 생길 수 있다, 외부에서 noise가 섞일 수 있고, 신호가 약해질 수 있다. <br>
원래 보냈던 데이터와 달라지고 오류가 발생, 이 오류는 체크섬 검사로 확인할 수 있다. <br>
잡음이 섞이면 프레임이나 패킷은 버려진다. <br>

### 패킷 유실률
* 네트워크 기기가 처리할 수 있는 한계를 넘어가면 패킷 유실이 발생할 수 있다.<br>
* 회선 신호가 약하거나 잡음이 섞이면 패킷 유실이 발생할 수 있다.<br>


#### 2.5.2 전송 속도와 전송 지연 시간
전송 속도 : 두 기기 간에 초당 전송될 수 있는 최대 데이터 양<br>
- 영향을 주는 것 : 선로의 종류와 품질, 두 기기의 소프트웨어와 하드웨어 종류<br>

지연 시간 : 레이턴시(latency), 두 기기 간에 데이터를 최소량 전송할 때 걸리는 시간<br>
- 영향을 주는 것 : 매체의 종류와 품질, 송-수신자 사이 라우터 처리 속도 <br>
 - 매체 종류 : 랜선(구리), 해저광케이블(광섬유), 무선(전파)<br>
 - 매체 품질이 낮으면 재전송에 의한 레이턴시로 이어짐 (패킷이 유실되기 때문에 잠시 후 다시 보내야함)<br>

레이턴시 측정 <br>
cmd - ping 도메인 <br>

라우터 경로 추적 <br>
cmd - tracert 도메인 <br>

#### 2.5.3 네트워크 품질 기준 세 가지
* 전송 속도(스루풋) : 전송될 수 있는 데이터의 단위 시간당 총량<br>
* 패킷 유실률 : 전송되는 데이터가 중간에 버려지는 비율<br>
* 레이턴시 : 전송되는 데이터가 목적지에 도착하는 데 걸리는 시간<br>

#### 2.5.4 무선 네트워크의 품질
~~

## 2.6 컴퓨터 네트워크에서 데이터 보내기와 받기

#### 2.6.1 UDP 네트워킹
##### UDP 
User Datagram Protocol의 약어, 사용자가 정의한 데이터그램(datagram)을 상대방에게 보낼 수 있게 하는 통신 규약(프로토콜)<br>

###### 데이터그램(datagram) : 약 64KB 이하의 이진 데이터, 스트림이 아닌 메시지 성질을 가짐

수신용 소켓, 송신용 소켓을 따로 만들지 않아도 됨, 이것 자체를 권장하지 않음

UDP<br>
장점 : 보내는 쪽에서 a, bb, ccc, dddd를 보내면 받는 쪽에서도 a, bb, ccc, dddd 형태로 받는 것이 보장된다.<br>
단점 : 사용법이 간단, 데이터 유실 또는 순서 뒤바뀜 같은 문제가 발생. <br>
	   따라서 데이터를 보낸 순서와 똑같이 받으려면 데이터가 정확하게 왔는지 검사하고, 잘못되었으면 다시 보내는 대책이 필요<br>
특징 : 다대다 통신이 가능<br>

네트워크 게임에서는 캐릭터가 이동할 때마다 계속해서 보내 주는 이동 정보(캐릭터 위치 등)를 보낼 때 UDP를 쓰기도 함.<br>
비록 중간에 데이터그램 유실이 생겨도 이어서 도착하는 캐릭터 이동 정보가 보완해 주기 때문 -> 뒤로 밀리는 현상은 없는가?<br>


* 소켓(socket)
프로그램이 UDP로 데이터를 주고받으려면 소켓을 생성해야 한다. <br>
소켓은 단말기 사이에 통신할 수 있게 운영체제에서 제공하는 자원.

```
// 송신
main()
{
    s = socket(UDP);                        // C기준 socket
    s.bind(any_port);                       // 0을 넣으면 운영체제가 알아서 사용 가능한 포트 할당
    s.sendTo("55.66.77.88:5959", "hello");  
    s.close();                              // 핸들이 닫히면 열린 포트는 다른 곳에서 사용 가능한 상태가 됨
}

// 수신
main()
{
    s = socket(UDP);
    s.bind(5959);                  // 송신 측에서 5959로 보냈기 때문에 고정
    r = s.recvfrom();              // 데이터가 도착하지 않았을 때 리턴되지 않음, 블로킹 상태
    print(r.srcAddrPort, r.data);  // 
    s.close();
}
```


#### 2.6.2 TCP 네트워킹
##### TCP 
Transmission Control Protocol(전송 제어 프로토콜)의 약어, 보내는 쪽 데이터가 받는 쪽에서 완전히 동일함을 보장해 주는 프로토콜

장점 : 간단하게 수신 보장을 받을 수 있음<br>
단점 :<br>
특징 : 데이터를 주고받기 전에 ‘연결’이라는 과정을 먼저 해야함(연결 지향형(connection oriented)), 일대일만 가능<br>
	   메시지 형태가 아니라 스트림 형태, 데이터를 뭉치거나 쪼갤 수 있음 (a,bb -> ab, b)<br>

```
// 송신
main()
{
    s = socket(TCP);                 //
    s.bind(any_port);				 //
    s.connect("55.66.77.88:5959");   // 연결에 성공할 때까지 블로킹 상태
    s.send("hello");                 // 
    s.close();
}

// 수신
main()
{
    s = socket(TCP);         // s는 listen socket
    s.listen(5959);          // TCP 연결을 위한 역할만 함
    s2 = s.accept();         // 연결될 때까지 블로킹 상태, 연결이 되면 s2에 새로운 socket 생성, 5959와는 다른 포트를 가지게 됨
    print(getpeeraddr(s2));  // 
    while (true)
    {
        r = s2.recv();       // 
        if (r.length = = 0)	 // 데이터 크기가 0이면 연결 종료
            break;           // 
        print(r);            // 
    }
    s2.close();              // 
}
```

![4주차_TCP_UDP차이.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_TCP_UDP%EC%B0%A8%EC%9D%B4.PNG)

#### 2.7 패킷 유실 시 UDP와 TCP에서 현상

![4주차_패킷 유실 시 TCP.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%ED%8C%A8%ED%82%B7%20%EC%9C%A0%EC%8B%A4%20%EC%8B%9C%20TCP.PNG)

![4주차_유실 시 UDP_TCP.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%EC%9C%A0%EC%8B%A4%20%EC%8B%9C%20UDP_TCP.PNG)



#### 2.8 주로 사용하는 메시지 형식

게임의 메시지는 크게 '텍스트'나 '바이너리 형식'으로 정의

* 텍스트 형식 : 메시지를 받는 쪽에서는 특정 글자가 나올 때까지 글자 검색을 하거나 구문 분석기(parser)를 동원하는 것이 일반적<br>
		과거는 개발자가 자체 정의, 요즘은 HTTP나 JSON 같은 표준화된 형식<br>

* 바이너리 형식 : 구문 분석기가 필요 없다. 처리 성능이 더 낫고 통신량도 적음. 해커 접근하기 어려움, 디버깅 지옥<br>


* 메타데이터 : 메시지가 자신이 어떤 내용을 담고 있는지에 대한 정보<br>
		데이터 통신량이 많아짐, 해커 쉽게 노출, 하위 호환성 측면에서 유리<br>

![4주차_메타데이터.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/0755dbd9dd79e91a4962aea1228179efc019fb1e/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0.PNG)


#### 2.9 네트워크 주소 변환(Network Address Translation, NAT)

* 다른 단말기로 전송되던 패킷의 송신자 주소나 수신자 주소가 다른 것으로 변환되는 과정을 의미
* NAT 변환을 하는 기기를 NAT 라우터라고 함. (인터넷 공유기 = NAT 라우터)

![4주차_NAT.PNG](https://github.com/Han-Ho-Study/ServerStudy/blob/30fe09cb343ba86c38ad3ce1a40a6a0b1cb9f980/%EC%A2%85%EA%B1%B4/%EC%B0%B8%EA%B3%A0%EC%9A%A9%20%EC%9D%B4%EB%AF%B8%EC%A7%80/4%EC%A3%BC%EC%B0%A8_NAT.PNG)

포트 매핑 엔트리 : 공유기가 송신자 엔드포인트와 수신자 엔드포인트를 매핑<br>
홀 펀칭 : 포트 매핑 엔트리가 만들어지는 과정<br>

공유기는 패킷 헤더를 변경, 패킷에 적혀 있던 주소를 변환해 버리기 때문에 NAT라고 불림<br>

스마트폰 통신 업체들이 사용하는 이 대규모 사용자용 NAT 라우터를 Carrier-grade NAT라고 하더라,,,<br>


#### 2.11 더 읽을거리

네트워크 게임의 성능 최적화를 위해 TCP를 직접 쓰지 않고 UDP 위에 TCP 같은 흐름 제어를 별도로 구현하는 경우도 있다. <br>
예를 들어 패킷을 유실하여 재송신을 의도적으로 더 빠르게 하고 싶을 때 유용한 방법. <br>
이를 구현하는 것을 흔히 Reliable UDP 혹은 RUDP라고 함. RUDP를 구현한 예로는 프라우드넷이나 RakNet 등이 있다.<br>

원격 프로시저 호출(Remote Procedure Call, RPC) 혹은 원격 메서드 호출(Remote Method Invocation, RMI) 자세한 것은 6.6절에서<br>
