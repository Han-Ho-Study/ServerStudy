# Week 5 / 3장 소켓 프로그래밍

## 3.1 블로킹 소켓
- 블로킹 : 디바이스에 처리 요청을 걸어 놓고 응답을 대기하는 함수를 호출할때 스레드에서 발생하는 대기현상
- 실제로는 RAM에 기록을 마친 후 즉시 블로킹이 끝남, RAM에 기록된 데이터를 추후 디스크에 기록

## 3.2 네트워크 연결 및 송신
```cpp
main()
{
  s = socket(TCP);                //tcp로 소켓 핸들 생성
  s.bind(any_port);               //빈포트를 차지함
  s.connect("55.66.77.88:5959");  //TCP연결을 시도(블로킹 발생)
  s.send("hello");                //데이터를 전송
  s.close();                      // 연결 해제
}
```

## 3.3 블로킹과 소켓 버퍼
- 소켓은 송신버퍼, 수신버퍼를 하나씩 가지고 있음(FIFO형태로 동작함)

## 3.4 네트워크 연결받기 및 수신
```cpp
main()
{
  s = socket(TCP);                 //tcp로 소켓 핸들 생성
  s.bind(5959);                    //5959포트를 차지함, 사용중인경우 이 함수는 실패함
  s.listen();                      //TCP 연결을 받는 역할, 즉시 리턴됨
  s2. = a.accept();                //새로운 소켓 핸들을 받아와서 통신
                                   //TCP연결이 들어올때까지 기다림. 리스닝 소켓은 연결을 수락하는 역할만함
  print(getpeeraddr(s2));          //주소 출력
  while(ture)
  {
    r = s2.recv();                  //새로운 데이터를 수신, 데이터가 없으면 블로킹
    if(r.length <= 0 )              //수신된 데이터의 크기가 0바이트라면 연결이 끝났음을 의미
      break;
    print(r);
  }
  s2.close();                      // 연결 해제
}
```

## 3.5 수신버퍼가 가득 차면 발생하는 현상
- TCP의 경우 : recv()는 1바이트라도 수신할 수 있으면 즉시 리턴, 1바이트라도 채워질때까지 블로킹, 연결이 끊어지지 않고 통신이 발생하지 않음, 느린쪽에 맞추어 동작(초당송신량을 줄임)
- UDP의 경우 : 수신측 버퍼가 꽉 차면 통신은 발생하나 패킷이 버려짐, sendTo는 블로킹이 발생하지 않음, 송신측에 활발한 송신활동이 멈추지 않음, 속도제한 없이 마구 송신하여 네트워크 경쟁에서 밀림

## 3.6 논블록 소켓
- 네트워킹 대상이 많을때 스레드간 컨텍스트 스위치가 대량 발생하여 자원낭비됨, 그래서 운영체제에서 소켓 함수가 블로킹되지 않는 API를 제공함
- 사용법 : 소켓을 논블록 소켓 모드로 전환
- would block : 블로킹 걸렸어야 할 상황이라 아무것도 하지않음의 리턴값
  - 송수신 함수 내에서의 리턴값일 경우 : 아무일도 일어나지 않음
  - connect함수의 리턴값일 경우 : 연결과정이 진행중인 상태를 확인하기위하여 0바이트 송신이라는 요령으로 소켓 상태를 확인
    - 0바이트 송신이 성공하면 연결되었다는 의미
    - ENOTCONN은 연결중의 의미
    - 기타 오류 코드가 나오면 TCP연결 시도가 실패한 것
  - 서버에서 receive함수 루프는 CPU를 차지하여 사용량 폭주 문제로 이어짐 -> 해결방법으로 select() or poll() 함수를 사용
  - accept 처리 : TCP연결이 아직 들어오지 않았음을 의미. 리스닝 소켓에서 I/O 가능 이벤트가 감지되면 호출하도록 하여 처리

## 3.7 Overlapped I/O 혹은 비동기 I/O
- 논블록 소켓의 장점
  - 스레드 블로킹이 없으므로 중도 취소 같은 통제가 가능
  - 스레드 개수가 1개이거나 적어도 소켓을 여러개 다룰 수 있음
  - 스레드 개수가 적거나 1개이므로 연산량이 낭비되지 않음
- 논블록 소켓의 단점
  - 소켓 I/O 함수의 리턴코드가 would block인 경우재시도 호출 낭비가 발생
  - 소켓 I/O 함수의 입력하는 데이터 블록에 대한 복사 연산이 발생
  - send 나 receive 함수 재시도 호출하는 API가 일관되지 않음

   ![01](https://github.com/Han-Ho-Study/ServerStudy/blob/main/한수/server/Image/week5_image1.PNG)
  
## 3.8 epoll
- 리눅스와 안드로이드에서만 사용가능
- iOS, MacOS, FreeBSD에서는 kqueue를 사용

## 3.9 IOCP
- Overlapped I/O가 완료되면 이를 감지해서 사용자에게 알려주는 역할
- IOCP에서 I/O가 완료되었음을 알려주는 완료신호를내장된 큐에서 꺼낼수 있어 모든 소켓들이 루프를 돌지 않아도 됨

   ![02](https://github.com/Han-Ho-Study/ServerStudy/blob/main/한수/server/Image/week5_image2.PNG)
