# Week 4 / 1장 멀티스레드(1.12장~1.17장)

## 1.12 스레드 풀링
- 서버 개발 시 고려해야하는 사항 : 개발을 용이하게 하기위해 클라이언트 수만큼 생성하게되면
  - 호출 스택 : 호출스택의 크기가 수십KB~ 수MB에 이른다
  - ContextSwitching : 개수가 많을수록 너무 많이 발생하게 됨
- 적절한 스레드 풀의 수는?
  - CPU 연산만 하는 스레드라면 서버의 CPU  개수와 동일하게 잡아도 충분
  - 데이터베이스나 파일 등 다른 것에 엑세스하면서 디바이스 타임이 발생할때는 CPU 개수보다 많아야 함

## 1.13 이벤트
- 잠자는 스레드를 깨우는 도구
```cpp
Event event1;

void Thread1()
{
  event1.Wait();
}

void Thread2()
{
  event1.Wait();
}

void Thread3()
{
  //둘 이상 이벤트를 기다리고 있으면 모든 스레드가 성공적으로 깨어나도록 해줌
  event1.PulseEvent();

  //둘 이상 스레드에서 wait할때 이벤트 상태 값을 0으로 바꾸게 되면 특정 할 수 없는 상태가 될 수 있음
  //event1.SetEvent(0);
}
```

## 1.14 세마포어
- VS 뮤텍스, CriticalSection
  - 뮤텍스는 Locking 메커니즘으로 락을 걸은 스레드만이 임계 구역을 나갈 때 락을 해제할 수 있지만 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 스레드도 signal을 사용해 락을 해제할 수 있음
  - 가장 큰 차이점은 동기화 대상의 갯수
    - 뮤텍스 : 동기화 대상이 only 1개일 때 사용
    - 세마포어 : 동기화 대상이 1개 이상일 때 사용
- 이벤트와 비슷하게 사용 가능(상태 값의 최댓값을 지정가능하고 이를 1로 했을때 이벤트와 사실상 동일함)

## 1.15 원자 조작
- 32비트나 64비트의 변수 타입에 여러스레드가 접근할때 한 스레드씩 처리됨을 보장
- 키워드 : volatile
- 뮤텍스나 임계역역의 내부에서는 원자조작을 활용하고 있음

## 1.16 멀티스레드 프로그래밍의 흔한 실수들
- 읽기와 쓰기 모두에 잠금하지 않기
- 잠금 순서 꼬임
- 너무 좁은 잠금 범위
- 디바이스 타임이 섞인 잠금
- 잠금의 전염성으로 발생한 실수
- 잠금된 뮤텍스나 임계영역 삭제
- 일관성 규칙 깨기
