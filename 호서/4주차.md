# 1.12 스레드 풀링
스레드의 개수를 지정할때 유용한 팁
- 디바이스 타임 ( I/O 타임 )등으로 스레드가 놀고 있는 시간이 많은 서버는 CPU보다 스레드를 많이 만들어야 효율적이다.

# 1.13 이벤트
잠자는 스레드를 깨우는 도구
자동 이벤트 and 수동 이벤트

실 사용 예제는?

# 1.14 세마포어
뮤텍스나 임계영역과는 다르게 자원에 접근할 수 있는 스레드 수를 정할 수 있다
세마포어와 이벤트의 유사성
- 세마포어도 다른 스레드를 깨울 수 있다.

실 사용 예제?

# 1.15 원자 조작
하드웨어 기능이다.
32비트나 64비트 변수 타입에 여러 스레드가 접근할 때 한 스레드씩만 처리됨을 보장함 ( ### 32비트나 64비트가 아닌건..? )
윈도우에서 임계영역 잠금은 원자조작 연산 2개로 끝난다.
Lock의 성능은 원자조작 수로 연결지을 수 있나?

# 1.16 멀티스레드 프로그래밍의 흔한 실수들
- Set, Get에 둘 다 Lock을 걸지 않기 : Get에 Lock을 걸지 않으면 쓰레기 값이 나올 수 있나?
- 잠금 순서가 다름
- 잠금 범위가 좁음
- 디바이스 타임이 섞인 잠금 : 로그 출력 & 콘솔 출력 실수
- 잠금의 전염성 : Lock을 잡아 얻어온 객체의 변조
- 합성 가능성의 부족 : DB 트랜션 ACID로 생각하면 될 듯
- 잠금된 Lock 객체 삭제
- 일관성 규칙 깨짐 

멀티 스레드 도움 프로그램 - Visual Studio Concurrency Visualizer, Intel Parallel Studio, Windows Performance toolkit


# 2.1 컴퓨터 네트워크를 구성하는 기기
LAN - 유선으로 연결된 네트워크 스위치와 컴퓨터의 구성

## 2.1.1 OSI 모델 ( 그 유명한 7계층? )
개발중 필요한 계층 - 세션(5), 표현(6), 응용(7)

## 2.1.2 OSI 모델의 계층 2 (데이터 링크 계층)
프레임 구성 요소
Preamble, SFD, DA, SA, Len/Type, Data, Padding, FCS : Padding은 많이 들어봤는데..

## 2.1.3 OSI 모델의 계층 3(네트워크 계층)
이곳에서 IP(Internet Protocol)를 사용한다

3계층에서 IP 패킷을 만들고 2계층으로 간다 -> 프레임안에 패킷이 포함되어 있는가?

# 2.2 인터넷

# 2.3 컴퓨터 네트워크 데이터
사실 패킷과 프레임은 잘 다루지 않는다 주로 다루는건 스트림과 메시지

## 2.3.1 스트림 형식
데이터의 흐름
A와 B가 스트림 형태로 송,수신할때 한번에 보내는/받는 개수는 다르지만 모두 함쳐서 이으면 동일하다. ( 그림 2-10 )

그렇기 때문에 헤더에 보낼 데이터의 크기를, 끝을 알리는 특정 구분자를 이용한다.

## 2.3.2 메시지 형식
스트림과 다르게 데이터의 시작과 끝은 따로 처리 없이 알 수 있다.
A와 B가 메시지 형태로 송,수신할때 한번에 보내는/받는 개수도 동일하고 모두 함친 결과물도 동일하다.
표 2-1을 보면 서버에서 보통 사용하는 형식으로 보인다.

3계층에서 다루는 IP 패킷의 크기는 한계가 있지만 스트림, 메시지 형식에서는 크기의 한계를 알 필요 없다.
운영체제에 내장된 네트워크 모듈인 네트워크 스택에서 스트림, 메시지를 단편화(fragmentation)하고 송신, 수신한다.

# 2.4 컴퓨터 네트워크 식별자
IPv4 프로토콜만 지원하는 네트워크 기기, IPv6 프로토콜만 지원하는 네트워크 기기를 다룰때는 주의가 필요하다 ( 호환되지 않음 )
IP는 네트워크의 주소를 담당하고 port는 프로세스의 주소를 담당한다. 
DNS

# 2.5 컴퓨터 네트워크의 품질과 특성
## 2.5.1 네트워크의 품질을 저해하는 것들
스위치나 라우터가 감당할 수 없는 양의 패킷이 오면 그냥 버린다 ( 패킷 유실 )
요즘 스위치나 라우터는 어떻게 동작할까?

OSI 1계층의 하드웨어 레벨 데이터 형태는 아날로그 신호이다.
아날로그 신호는 외부 조건으로 오류가 생길 수 있다. 이 오류는 계층 2나 계층 3의 체크섬 검사로 걸러짐( 또 버림 )

## 2.5.2 전송 속도와 전송 지연 시간(레이턴시)
전송 속도 : 두 기기 간에 초당 전송될 수 있는 최대 데이터 양(B/s)
레이턴시 : 데이터를 전송할 때 걸리는 시간(ms) - 패킷 유실시 다시 보내기 위한 시간도 레이턴시에 포함됨
방화벽도 레이턴시에 영향을 줌
레이턴시의 대부분은 네트워크 기기안에서의 처리하는 시간에 영향을 받는다

## 2.5.3 네트워크 품질 기준 세 가지
전송 속도
패킷 유실률
레이턴시

## 2.5.4 무선 네트워크의 품질
패킷 유실은 당연하지만 레이턴시도 느리다.
와이파이 하드웨어와 운영체제 소프트웨어에도 영향을 받는다.
무선 통신 방식 CSMA(Carrier Sense Multiple Access)

# 2.6 컴퓨터 네트워크에서 데이터 보내기와 받기
TCP와 UDP는 OSI 4계층이다
## 2.6.1 UDP 네트워킹
User Datagram Protocol
메시지 형태, UDP로 데이터를 주고받으려면 송,수신측 Port가 UDP로 설정되어 있어야 한다. ( InBound, outBound 세팅? )
순서는 바뀔 수 있지만 유실될 순 있지만 잘못된 데이터를 받진 않는다. (동영상, 이동등에 사용)
여러 소캣이 하나의 Port를 공유할 수 있는 옵션이 있나보다
소캣을 닫을때는 4Hand Shake가 있어야함
UDP는 다대다 통신이 가능하다
0바이트 수신은 정상으로 받아드린다.
레이턴시 : 네트워크 기기의 레이턴시

## 2.6.2 TCP 네트워킹
Transmission Control Protocol
UDP와 다르게 연결 과정이 하나 더 있다. ( 연결은 1:1만 가능하다 ) 하지만 유실되지 않는다.
스트림 형태, 스트림 데이터는 세그먼트로 쪼개지는데 수신측은 받은 새그먼트를 송신측에 반송함으로 데이터의 유실을 방지한다.
TCP는 송신측, 수신측의 Socket 설정 방식이 다르다. 송신은 클라이언트, 수신은 서버 역할
서버는 클라이언트 연결을 받을 listen Socket과 연결된 클라이언트와 통신할 Socket 두종류의 Socket을 사용한다.
0바이트 수신은 연결이 종료되었음을 의미한다. << Socket을 안전하게 제거하는건 프로그래머의 영역이다. ( 수신측 코드 6, 8 )
한쪽에서 0바이트를 송신해서 연결이 끊기면 송신한쪽도 0바이트를 수신한다.
레이턴시 : 네트워크 기기의 레이턴시 + 패킷 유실률 * 재전송 대기시간

# 2.7 패킷 유실 시 UDP와 TCP에서 현상
UDP : 데이터그램이 클수록 유실률이 높음 ( IP패킷이 쪼개져서 정송되기 때문 )
TCP : 새그먼트 반송을 받지 않았으니 다시 패킷을 보냄, 받을 패킷이 남아있으면 데이터 스트림이 완료되지 않음
패킷 유실률은 생각보다 클지도...

# 2.8 주로 사용하는 메시지 형식
텍스트 형식 : HTTP, JSON
바이너리 형식 : 메타 데이터가 필요하다 ( 우리가 아는 패킷 클래스는 아닌것 같고 JSON 처럼 Key와 Value 형식으로 보내는듯) ** 패킷 버전 관리가 쉽다?
모바일 앱의 경우 업데이트 없이 사용할 수 있다 << 패킷을 어떻게 만들었길래..? ( 헤더에 버전을 적어놨나 )

# 2.9 네트워크 주소 변환
Network Address Translation, NAT
NAT 라우터 = 공유기
IP하나로 여러 기기가 인터넷을 사용할 수 있음

# 2.10 요약
아니 이것만 보면 2장은 정리 안해도 되는거였나

# 2.11 더 읽을 거리
...
