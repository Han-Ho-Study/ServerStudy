3장 소켓프로그래밍
게임 서버에서는 다루어야 하는 소켓의 갯수가 많음
TCP 통신인 경우 클라 수만큼 필요함.
소켓은 비동기 입출력 상태로 다루어야함
- 논블로킹 소켓
- Overlapped I/O 
방식이 있음.

이것들을 이해하기위해
블로킹
논블로킹
Overlapped I/O 
epoll
I/O completion Port
를 3장에서 다룰예정

3.1 블로킹 소켓
1. 디바이스에 처리요청을 걸어놓아서 쓰래드가 응답을 대기하는 상태를 블로킹이라고 함.
2. 소켓이나 파일 핸들에 대한 함수를 호출해서 블로킹된 쓰레드는 cpu연산을 사용하지 않음. waitable state
3. 쓰레드에서 네트워크 수신하는 함수를 호출하면 수신할 수 있는 데이터가 생길때까지 쓰레드는 waitable state 상태가됨

3.2 네트워크 연결 및 송신
1. TCP는 연결지향형 프로토콜 / 일대일 통신만 허락 / TCP 소켓 1개는 1개만 통신 가능
2. 
- 소켓생성 socket
- 본인 포트 바인드 bind
- 연결할 상대 ip port 로 connect -> 블로킹이 일어난다. 상대와의 연결이 성공 실패 하면 결과 알기 가능
- 보낼 메세지 send -> 운영체제에서 데이터 전송처리가 완료 하면 리턴 
- 소켓 종료 close
3. 이 방식은 생각처럼 잘 동작하지 않음 / 가끔 데이터를 수신 못함 / 왜?
4. 운영 체제가 소켓 송신과 수신을 어떻게 처리하는지 + 소켓 버퍼에 대한 이해 필요.

3.3 블로킹과 소켓 버퍼
1. 소켓은 송신 버퍼와 수신버퍼를 가지고 있음
2. 송신버퍼는 일련의 바이트 배열임 / FIFO로 처리함
3. 송신 버퍼크기가 꽉차면 블로킹 발생 송신으로 버퍼가 비어야 블로킹 해제

3.4 네트워크 연결 받기 및 수신
1. TCP 소켓 생성 -> socket
2. 5959 포트 점유 -> bind(5959)
3. 받는 역할 -> listen() / 바로 리턴
4. TCP 연결이 들어 올떄 까지 기다림 / accept() / 연결 하면 리턴 연결 수락 역할만 함
5. 보낸쪽 주소 출력 / print(getpeeraddr(s2))
6. 데이터 수신 수신할 데이터가 없으면 블로킹 / 수신할 수 있는데이터가 있을때 까지 블로킹
7. 받은데이터 크기가 0이라면 tcp 연결 끝냄
8. 소켓을 닫음
9. 수신버퍼가 완전 비어져 있으면 블로킹

3.5 수신버퍼가 가득차면 발생하는 현상
1. 수신 함수에서 수신데이터를 꺼내오는 속도가 수신데이터를 채우는 속도보다 느리면 수신버퍼가 가득 참
2. 이런 현상이 발생하면  tcp 에서 송신하는 send가 블로킹 됨
3. 연결은 유지되고 느린쪽에 송신이 맞춰 주는 상태
4. UDP 소켓의 경우 수신버퍼가 가득차버렸다 해서 send를 블로킹하지 않음 그래서 유실발생
5. 라우터에 너무 많은 데이터가 몰리는 경우 주변 데이터를 받는 사용자가 원활이 패킷처리를 못하게되는데
6. TCP의 경우 송신하는양이 수신하는 쪽보다 많은 데이터를 보내면 알아서 운영체제가 조절하기 때문에 라우터에 네트워크 경쟁 발생을 유발 시키지 않음
7. UDP의 경우 TCP와 달리 이런 제어기능이 없어서 주변 네트워크가 영향을 받음

3.6 논블록 소켓
1. 여러명과 통신을 할때 쓰레드를 사용자 수만큼 만들면 너무 양이 많기 때문에 대량의 컨텐스트 스위치 비용이 발생함
2. 송신함수는 버퍼에 빈공간이 없으면 블로킹이 일어남
3. 이런 블로킹 현상을 해결하기위해 운영체제는 논블로킹 API를 제공함
4. 
- 소켓을 논블록 소켓으로 모드 전환
- 논블록 소켓에 대해 똑같이 송신 수신 연결사용
- 논블록 소켓함수는 항상 즉시 리턴 성공 or block

5. 논블록 소켓함수 즉시 리턴하기 때문에 CPU를 100%현상이 나올 수 있다.

6. 이걸 해결하기위해 select나 poll 같은 함수를 제공한다. select는 사용가능한 소켓이 있으면 즉시 리턴 없으면 특정시간만큼 기다림

7. 논블록 accept 도 마찬가지로 select를 cpu이득이 있어서 사용하면 좋다.

3.7 Overlapped I/O 혹은 비동기 I/O
1. TCP의 논블락의 경우 5바이트를 보내고 싶을때 1바이트가 비어있으면 1바이트만 보내기 때문에 결과적으론 보내서 성공
2. UDP의 경우 5바이트를 보내고 싶을때 1바이트가 비어있으면 실패 전부 다같이 보내야하기때문에 재시도 이슈 생김
3. send 시 메모리 복사 이슈 
4. 123번을 overlapped i/o가 해결 가능
5. overlapped i/o의 장단점 책 173페이지 참고
6. 너무 소켓 갯수가 많으면 너무 많은 루프를 돈다 그걸 해결 하기 위해 IOCP 와 epoll 등장!

3.8 epoll 
1. epoll은 I/O 가능 상태가 되면 이를 감지해 사용자에게 알려줌!
2. 소켓이 I/O 가능할때 알려주는게 아니고 사용이 불가능했다가 사용가능할때 알려줌
3. 그렇기 때문에 항상 사용 가능하다고 Event를 줬으면 사용 데이터를 전부처리하여 다시 epoll event를 기다리는 상태로 만들어 주어야함

3.9 iocp
1. epoll과 마찬가지로 Overlapped I/O를 다루는 운영체제에 대응한 기술 (iocp가 먼저나옴)
2. i/o가 완료되는순간 푸시
3. Overlapped를 걸어두고 완료된 소켓만 처리
4. wait 도중에 완료 되면 기다리던 시간과 상관없이 즉시 리턴
5. 처리 완료이후에 다시 Overlapped를 걸어둠

6. epoll의 경우 다른 쓰레드에서 같은 소켓을 접근할때 I/O 완료 상태가 아니기때문에 문제 발생 할 수 있음
7. iocp의 경우는 다른 쓰레드에서 같은 소켓을 접근하려면 이미 I/O 완료 상태이기 때문에 상관없음
8. epoll의 이런 문제를 해결하기위해 쓰레드에서 접근 가능한 소켓을 나눠두기도 함.